@attribute [Route($"/{Routing.Lesson}")]

@using JDev.Tuteee.Rest.ApiClient.ApiClients
@using JDev.Tuteee.Rest.ApiClient.DTOs
@using Microsoft.AspNetCore.Authorization

@inherits CancellableComponentBase

@inject ILessonRestApiClient LessonRestApiClient
@inject IHomeworkAttachmentRestApiClient HomeworkAttachmentRestApiClient
@inject IFileRestApiClient FileRestApiClient
@inject IJSRuntime JsRuntime
@attribute [StreamRendering]
@rendermode InteractiveServer
@attribute [Authorize(Roles = "Admin")]

<PageTitle>@TuteeName</PageTitle>

<Breadcrumb Items="_navItems"></Breadcrumb>

<Modal @ref="_modal" Title="Enter lesson details">
    <BodyTemplate>
        <div class="d-flex flex-column">
            <InputFile OnChange="LoadFile"/>
            Filename
            <TextInput @bind-Value="@_filename"/>
        </div>
    </BodyTemplate>
    <FooterTemplate>
        <Button Color="ButtonColor.Primary" @onclick="OnHideAddAttachmentModal">Add attachment</Button>
    </FooterTemplate>
</Modal>

<h4>Overview</h4>
@if (_lesson is null)
{
    <p>
        <em>Loading...</em>
    </p>
}
else
{
    <p>Start: @_lesson.StartTime.ToString("t")</p>
    <p>End: @_lesson.EndTime.ToString("t")</p>
}
<h4>Cost</h4>
@if (_lesson is null)
{
    <p>
        <em>Loading...</em>
    </p>
}
else
{
    <p>¬£@_lesson.CostString</p>
}

<div class="d-flex flex-row justify-content-between my-2">
    <h4>Homework</h4>
    <Button Color="ButtonColor.Primary">Edit</Button>
</div>

@if (_lesson is null)
{
    <p>
        <em>Loading...</em>
    </p>
}
else
{
    <p>@_lesson.HomeworkInstructions</p>
    <div class="d-flex flex-row justify-content-between my-2">
        <h4>Homework attachments</h4>
        <Button Color="ButtonColor.Primary" @onclick="OnShowAddAttachmentModal">Add attachments</Button>
    </div>
    @foreach (var ha in _homeworkAttachments)
    {
        <div class="d-flex flex-row">
            <a class="styled-pointer" @onclick="() => DownloadFile(ha)">@Path.GetFileName(ha.FileName)</a>
            <a class="styled-pointer" @onclick="() => DeleteFile(ha)">üóëÔ∏è</a>
        </div>
    }
}
<script>
    window.downloadFileFromStream = async (fileName, contentStreamReference) => {
        const arrayBuffer = await contentStreamReference.arrayBuffer();
        const blob = new Blob([arrayBuffer]);
        const url = URL.createObjectURL(blob);
        const anchorElement = document.createElement('a');
        anchorElement.href = url;
        anchorElement.download = fileName ?? '';
        anchorElement.click();
        anchorElement.remove();
        URL.revokeObjectURL(url);
    }
</script>


@code {
    [Parameter]
    public int LessonId { get; set; }
    private List<BreadcrumbItem> _navItems = default!;
    private Modal _modal = default!;
    private LessonDto? _lesson;
    private TuteeDto? _tutee;
    private ClientDto? _client;
    private IReadOnlyList<HomeworkAttachmentDto> _homeworkAttachments = [];
    private string _filename = default!;
    private string _temporaryFileName = default!;

    private string TuteeName => $"{_tutee?.FirstName} {_tutee?.LastName}";
    private string ClientName => $"{_client?.HolderFirstName} {_client?.HolderLastName}";

    protected override async Task OnInitializedAsync()
    {
        _lesson = await LessonRestApiClient.GetAsync(LessonId, CancellationToken);
        _tutee = _lesson.Tutee;
        _client = _tutee.Client;
        _homeworkAttachments = await HomeworkAttachmentRestApiClient.GetListAsync(LessonId, CancellationToken);
        _navItems =
        [
            new BreadcrumbItem { Text = $"{ClientName} üìÇ", Href = $"clients/{_client!.ClientId}" },
            new BreadcrumbItem { Text = $"{TuteeName} üéì", Href = $"tutees/{_tutee.TuteeId}" },
            new BreadcrumbItem { Text = $"{_lesson.StartTime:MM/dd/yyyy} üìö", IsCurrentPage = true }
        ];
    }

    private async Task DownloadFile(HomeworkAttachmentDto dto)
    {
        var response = await HomeworkAttachmentRestApiClient.GetAsync(dto.HomeworkAttachmentId, CancellationToken);
        var fileName = Path.GetFileName(response.FileName);
        var stream = new MemoryStream(response.Contents);
        using var streamRef = new DotNetStreamReference(stream: stream);
        await JsRuntime.InvokeVoidAsync("downloadFileFromStream", fileName, streamRef);
    }
    
    private async Task DeleteFile(HomeworkAttachmentDto dto)
    {
        await HomeworkAttachmentRestApiClient.DeleteAsync(dto.HomeworkAttachmentId, CancellationToken);
        _homeworkAttachments = await HomeworkAttachmentRestApiClient.GetListAsync(_lesson.LessonId.Value, CancellationToken);
    }

    private async Task OnHideAddAttachmentModal()
    {
        await HomeworkAttachmentRestApiClient.SaveAsync(_lesson.LessonId.Value, new HomeworkAttachmentDto
        {
            FileName = _filename,
            TemporaryFileName = _temporaryFileName,
            LessonId = _lesson!.LessonId
        }, CancellationToken);
        _homeworkAttachments = await HomeworkAttachmentRestApiClient.GetListAsync(LessonId, CancellationToken);
        await _modal.HideAsync();
    }

    private async Task OnShowAddAttachmentModal()
    {
        await _modal.ShowAsync();
    }

    private async Task LoadFile(InputFileChangeEventArgs obj)
    {
        var file = obj.File;
        var tempName = $"{Guid.NewGuid()}{Path.GetExtension(file.Name)}";
        _temporaryFileName = tempName;
        _filename = file.Name;
        using var memoryStream = new MemoryStream();
        await file.OpenReadStream(maxAllowedSize: 10 * 1024 * 1024).CopyToAsync(memoryStream);
        var byteArray = memoryStream.ToArray();
        await FileRestApiClient.SaveTemporaryAsync(new FileDto
        {
            Contents = byteArray,
            FileName = tempName
        }, CancellationToken);
    }
}